<div id="easy-form-{{ block.id }}" class="form-builder-container" data-form-id="{{ block.settings.form_id }}" style="width: {{ block.settings.form_width }}%; margin: 0 auto; text-align: {{ block.settings.form_alignment }};"><div class="form-loading">Loading form...</div></div>
<script>
(function() {
  'use strict';
  function injectFormStyles() {
    if (document.getElementById('easy-form-builder-styles')) {
      return;
    }
    
    const styleElement = document.createElement('style');
    styleElement.id = 'easy-form-builder-styles';
    styleElement.textContent = `
      /* File Upload Styles */
      .upload-area,
      .code-form-app .upload-area,
      .contact-form .upload-area {
        width: 100%;
        min-height: 150px;
        border: 1px dashed #eb1256;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
        padding: 10px;
      }
      .upload-p,
      .code-form-app .upload-p,
      .contact-form .upload-p {
        margin: 0;
        padding: 0;
        text-align: center;
      }
      .file_button,
      .code-form-app .file_button,
      .contact-form .file_button {
        background-color: #ffffff;
        padding: 10px 20px;
        box-shadow: 0px 0px 5px #00000045;
        margin-top: 5px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
      }
      input[type="file"][data-type="file"],
      #fileimage,
      input[id^="fileimage-"] {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        opacity: 0;
        cursor: pointer;
        z-index: 10;
      }
      .img-container,
      .code-form-app .img-container,
      .contact-form .img-container {
        width: 100% !important;
        display: flex !important;
        flex-wrap: wrap !important;
        gap: 10px !important;
        justify-content: center !important;
        align-items: center !important;
        padding: 10px !important;
        min-height: 50px !important;
        position: relative !important;
        z-index: 5 !important;
        visibility: visible !important;
        opacity: 1 !important;
        box-sizing: border-box !important;
      }
      .upload-area.has-files .upload-p,
      .upload-area.has-files .file_button {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        height: 0 !important;
        width: 0 !important;
        overflow: hidden !important;
      }
      .img-preview-wrapper {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 5px;
        max-width: 200px;
        z-index: 3;
      }
      .img-preview {
        width: 150px !important;
        max-width: 100% !important;
        max-height: 150px !important;
        height: auto !important;
        object-fit: contain !important;
        border: 1px solid #eb1256 !important;
        border-radius: 4px !important;
        background: #fff !important;
        display: block !important;
        margin: 0 auto !important;
      }
      .img-remove-btn {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background-color: #d32f2f;
        border: 2px solid #fff;
        color: #fff;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        line-height: 1;
        padding: 0;
      }
      .img-remove-btn:hover {
        background-color: #b71c1c;
        transform: scale(1.1);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      }
      .img-remove-btn:active {
        transform: scale(0.95);
      }
      
      /* Remove list markers from checkbox and radio lists - comprehensive rules */
      .code-form-control ul,
      .contact-form .code-form-control ul,
      .code-form-control ul.flex-wrap,
      .contact-form .code-form-control ul.flex-wrap,
      .code-form-control ul li,
      .contact-form .code-form-control ul li,
      .code-form-control .globo-list-control,
      .contact-form .code-form-control .globo-list-control,
      .code-form-control li.globo-list-control,
      .contact-form .code-form-control li.globo-list-control,
      .code-form-control li,
      .contact-form .code-form-control li,
      ul.code-form-control,
      ul.contact-form,
      li.code-form-control,
      li.contact-form,
      .code-form-control ul li.globo-list-control,
      .contact-form .code-form-control ul li.globo-list-control {
        list-style: none !important;
        list-style-type: none !important;
        list-style-position: outside !important;
        list-style-image: none !important;
        margin: 0 !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
        padding: 0 !important;
        padding-left: 0 !important;
        padding-right: 0 !important;
      }
      /* Remove any pseudo-elements that might create markers */
      .code-form-control ul::before,
      .contact-form .code-form-control ul::before,
      .code-form-control ul::after,
      .contact-form .code-form-control ul::after,
      .code-form-control ul.flex-wrap::before,
      .contact-form .code-form-control ul.flex-wrap::before,
      .code-form-control ul.flex-wrap::after,
      .contact-form .code-form-control ul.flex-wrap::after,
      .code-form-control li::before,
      .contact-form .code-form-control li::before,
      .code-form-control li::after,
      .contact-form .code-form-control li::after,
      .code-form-control li.globo-list-control::before,
      .contact-form .code-form-control li.globo-list-control::before,
      .code-form-control li.globo-list-control::after,
      .contact-form .code-form-control li.globo-list-control::after,
      .code-form-control .globo-list-control::before,
      .contact-form .code-form-control .globo-list-control::before,
      .code-form-control .globo-list-control::after,
      .contact-form .code-form-control .globo-list-control::after,
      .code-form-control ul li.globo-list-control::before,
      .contact-form .code-form-control ul li.globo-list-control::before,
      .code-form-control ul li.globo-list-control::after,
      .contact-form .code-form-control ul li.globo-list-control::after {
        display: none !important;
        content: "" !important;
        visibility: hidden !important;
        opacity: 0 !important;
        width: 0 !important;
        height: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
        background: none !important;
        border: none !important;
      }
      /* Remove markers from all list items globally within form controls */
      .code-form-control ul *,
      .contact-form .code-form-control ul * {
        list-style: none !important;
        list-style-type: none !important;
        list-style-image: none !important;
      }
      
      /* Checkbox Styles */
      .code-form-control .checkbox-wrapper,
      .contact-form .code-form-control .checkbox-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        min-height: 24px;
        list-style: none !important;
      }
      .code-form-control .checkbox-wrapper.checkbox-option,
      .contact-form .code-form-control .checkbox-wrapper.checkbox-option {
        display: flex !important;
        align-items: center;
      }
      
      /* Radio Button Styles */
      .code-form-control .radio-wrapper,
      .contact-form .code-form-control .radio-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        min-height: 24px;
        list-style: none !important;
      }
      .code-form-control .radio-wrapper .radio-input,
      .contact-form .code-form-control .radio-wrapper .radio-input {
        position: absolute !important;
        top: 1px !important;
        left: 0px !important;
        width: 20px !important;
        height: 20px !important;
        margin: 0 !important;
        padding: 0 !important;
        opacity: 0 !important;
        cursor: pointer !important;
        z-index: 3 !important;
        pointer-events: auto !important;
      }
      .code-form-control .radio-wrapper .radio-label,
      .contact-form .code-form-control .radio-wrapper .radio-label {
        display: inline-block;
        padding-left: 28px;
        cursor: pointer;
        position: relative;
        user-select: none;
      }
      .code-form-control .radio-wrapper .radio-input~.radio-label:before,
      .contact-form .code-form-control .radio-wrapper .radio-input~.radio-label:before {
        position: absolute;
        top: 1px;
        left: 0px;
        display: block;
        width: 20px;
        height: 20px;
        content: "";
        margin: 0;
        pointer-events: none;
        user-select: none;
        background-color: #fff;
        box-shadow: none;
        border: 2px solid #d1d5db;
        box-sizing: border-box;
        box-shadow: 0 1px 3px rgba(50,50,93,.15), 0 1px 0 rgba(0,0,0,.02);
        border-radius: 50%;
        transition: all .2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        z-index: 1;
      }
      .code-form-control .radio-wrapper .radio-input:checked~.radio-label:before,
      .contact-form .code-form-control .radio-wrapper .radio-input:checked~.radio-label:before {
        border-color: #EB1256;
        box-shadow: 0 4px 6px rgba(50,50,93,0.11), 0 1px 3px rgba(0,0,0,0.08);
        background-color: #EB1256;
      }
      .code-form-control .radio-wrapper .radio-input~.radio-label:after,
      .contact-form .code-form-control .radio-wrapper .radio-input~.radio-label:after {
        position: absolute;
        top: 50%;
        left: 10px;
        transform: translate(-50%, -50%);
        display: block;
        width: 8px;
        height: 8px;
        content: "";
        margin: 0;
        background-color: #fff;
        border-radius: 50%;
        opacity: 0;
        transition: opacity .2s;
        z-index: 2;
        pointer-events: none;
      }
      .code-form-control .radio-wrapper .radio-input:checked~.radio-label:after,
      .contact-form .code-form-control .radio-wrapper .radio-input:checked~.radio-label:after {
        opacity: 1;
      }
      .code-form-control .checkbox-wrapper .checkbox-input,
      .contact-form .code-form-control .checkbox-wrapper .checkbox-input {
        position: absolute !important;
        top: 1px !important;
        left: 0px !important;
        width: 20px !important;
        height: 20px !important;
        margin: 0 !important;
        padding: 0 !important;
        opacity: 0 !important;
        cursor: pointer !important;
        z-index: 3 !important;
        pointer-events: auto !important;
      }
      .code-form-control .checkbox-wrapper .checkbox-label,
      .contact-form .code-form-control .checkbox-wrapper .checkbox-label {
        display: inline-block;
        padding-left: 28px;
        cursor: pointer;
        position: relative;
        user-select: none;
      }
      .code-form-control .checkbox-wrapper .checkbox-input~.checkbox-label:before,
      .contact-form .code-form-control .checkbox-wrapper .checkbox-input~.checkbox-label:before {
        position: absolute;
        top: 1px;
        left: 0px;
        display: block;
        width: 20px;
        height: 20px;
        content: "";
        margin: 0;
        pointer-events: none;
        user-select: none;
        background-color: #fff;
        box-shadow: none;
        border: 1px solid #d1d5db;
        box-sizing: border-box;
        box-shadow: 0 1px 3px rgba(50,50,93,.15), 0 1px 0 rgba(0,0,0,.02);
        border-radius: 0.25rem;
        transition: all .2s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        z-index: 1;
      }
      .code-form-control .checkbox-wrapper .checkbox-input:checked~.checkbox-label:before,
      .contact-form .code-form-control .checkbox-wrapper .checkbox-input:checked~.checkbox-label:before {
        border-color: #EB1256;
        box-shadow: 0 4px 6px rgba(50,50,93,0.11), 0 1px 3px rgba(0,0,0,0.08);
        background-color: #EB1256;
      }
      .code-form-control .checkbox-wrapper .checkbox-input~.checkbox-label:after,
      .contact-form .code-form-control .checkbox-wrapper .checkbox-input~.checkbox-label:after {
        position: absolute;
        top: 1px;
        left: 0px;
        display: block;
        width: 20px;
        height: 20px;
        content: "";
        margin: 0;
        background-repeat: no-repeat;
        background-position: center;
        background-size: 12px 12px;
        opacity: 0;
        transition: opacity .2s;
        z-index: 2;
        pointer-events: none;
      }
      .code-form-control .checkbox-wrapper .checkbox-input:checked~.checkbox-label:after,
      .contact-form .code-form-control .checkbox-wrapper .checkbox-input:checked~.checkbox-label:after {
        background-image: url('https://codelocksolutions.com/form_builder/assets/images/checkbox.svg');
        opacity: 1;
      }
      
      /* Rating Star Styles - Horizontal Display */
      .code-form-control .star-rating>fieldset,
      .contact-form .code-form-control .star-rating>fieldset {
        border: none;
        display: flex;
        flex-direction: row-reverse;
        justify-content: flex-end;
        padding: 0;
        margin: 0;
        overflow: visible;
        line-height: 1;
      }
      .code-form-control .star-rating>fieldset label,
      .contact-form .code-form-control .star-rating>fieldset label {
        width: 1.5em;
        height: 1.5em;
        padding: 0;
        overflow: visible;
        white-space: nowrap;
        cursor: pointer !important;
        font-size: 200%;
        color: rgba(0,0,0,0);
        position: relative;
        margin: 0 2px;
        display: block;
        line-height: 1;
        box-sizing: border-box;
        flex-shrink: 0;
        background: transparent !important;
      }
      .code-form-control .star-rating>fieldset input[type="radio"],
      .contact-form .code-form-control .star-rating>fieldset input[type="radio"] {
        position: absolute;
        opacity: 0;
        width: 1.5em;
        height: 1.5em;
        margin: 0;
        padding: 0;
        cursor: pointer !important;
        z-index: 10;
        top: 0;
        left: 0;
        pointer-events: auto !important;
      }
      .code-form-control .star-rating>fieldset label:hover,
      .contact-form .code-form-control .star-rating>fieldset label:hover {
        cursor: pointer !important;
      }
      .code-form-control .star-rating>fieldset input[type="radio"]:hover,
      .contact-form .code-form-control .star-rating>fieldset input[type="radio"]:hover {
        cursor: pointer !important;
      }
      .code-form-control .star-rating>fieldset label:before,
      .contact-form .code-form-control .star-rating>fieldset label:before {
        content: url('https://codelocksolutions.com/form_builder/assets/images/download.svg');
        display: block;
        width: 1.5em;
        height: 1.5em;
        position: absolute;
        top: 0;
        left: 0;
        object-fit: contain;
        line-height: 1;
      }
      .code-form-control .star-rating>fieldset label.star-filled:before,
      .contact-form .code-form-control .star-rating>fieldset label.star-filled:before,
      .code-form-control .star-rating>fieldset label[data-star-state="filled"]:before,
      .contact-form .code-form-control .star-rating>fieldset label[data-star-state="filled"]:before {
        content: url('https://codelocksolutions.com/form_builder/assets/images/star.svg') !important;
        display: block !important;
        width: 1.5em !important;
        height: 1.5em !important;
      }
      .code-form-control .star-rating>fieldset label.star-empty:before,
      .contact-form .code-form-control .star-rating>fieldset label.star-empty:before,
      .code-form-control .star-rating>fieldset label[data-star-state="empty"]:before,
      .contact-form .code-form-control .star-rating>fieldset label[data-star-state="empty"]:before {
        content: url('https://codelocksolutions.com/form_builder/assets/images/download.svg') !important;
        display: block !important;
        width: 1.5em !important;
        height: 1.5em !important;
      }
      .code-form-control .star-rating>fieldset label:hover:before,
      .contact-form .code-form-control .star-rating>fieldset label:hover:before {
        content: url('https://codelocksolutions.com/form_builder/assets/images/star.svg');
      }
      /* When a star is checked, fill that star and all stars with higher values (which appear to the left in RTL) */
      .code-form-control .star-rating>fieldset input[value="5"]:checked ~ input[value="4"] ~ input[value="3"] ~ input[value="2"] ~ input[value="1"] ~ label:before,
      .contact-form .code-form-control .star-rating>fieldset input[value="5"]:checked ~ input[value="4"] ~ input[value="3"] ~ input[value="2"] ~ input[value="1"] ~ label:before,
      .code-form-control .star-rating>fieldset input[value="4"]:checked ~ input[value="3"] ~ input[value="2"] ~ input[value="1"] ~ label:before,
      .contact-form .code-form-control .star-rating>fieldset input[value="4"]:checked ~ input[value="3"] ~ input[value="2"] ~ input[value="1"] ~ label:before,
      .code-form-control .star-rating>fieldset input[value="3"]:checked ~ input[value="2"] ~ input[value="1"] ~ label:before,
      .contact-form .code-form-control .star-rating>fieldset input[value="3"]:checked ~ input[value="2"] ~ input[value="1"] ~ label:before,
      .code-form-control .star-rating>fieldset input[value="2"]:checked ~ input[value="1"] ~ label:before,
      .contact-form .code-form-control .star-rating>fieldset input[value="2"]:checked ~ input[value="1"] ~ label:before,
      .code-form-control .star-rating>fieldset input[value="1"]:checked ~ label:before,
      .contact-form .code-form-control .star-rating>fieldset input[value="1"]:checked ~ label:before {
        content: url('https://codelocksolutions.com/form_builder/assets/images/star.svg');
      }
      /* Also fill the label for the checked input itself */
      .code-form-control .star-rating>fieldset input:checked + label:before,
      .contact-form .code-form-control .star-rating>fieldset input:checked + label:before {
        content: url('https://codelocksolutions.com/form_builder/assets/images/star.svg');
      }
      /* Ensure inputs and labels are clickable */
      .code-form-control .star-rating>fieldset input[type="radio"],
      .contact-form .code-form-control .star-rating>fieldset input[type="radio"] {
        pointer-events: auto !important;
      }
      .code-form-control .star-rating>fieldset label,
      .contact-form .code-form-control .star-rating>fieldset label {
        pointer-events: auto !important;
      }
      
      /* Options per line styles for checkboxes and radio buttons */
      .globo-list-control.option-1-column,
      .contact-form .globo-list-control.option-1-column {
        width: 100%;
      }
      .globo-list-control.option-2-column,
      .contact-form .globo-list-control.option-2-column {
        width: 50%;
      }
      .globo-list-control.option-3-column,
      .contact-form .globo-list-control.option-3-column {
        width: 33.333%;
      }
      .globo-list-control.option-4-column,
      .contact-form .globo-list-control.option-4-column {
        width: 25%;
      }
      .globo-list-control.option-5-column,
      .contact-form .globo-list-control.option-5-column {
        width: 20%;
      }
      .globo-list-control,
      .contact-form .globo-list-control {
        padding: 0 5px;
        position: relative;
        box-sizing: border-box;
      }
      
      /* Layout column width styles */
      .code-form-control.layout-1-column,
      .contact-form .code-form-control.layout-1-column {
        width: 8.333%;
      }
      .code-form-control.layout-2-column,
      .contact-form .code-form-control.layout-2-column {
        width: 16.666%;
      }
      .code-form-control.layout-3-column,
      .contact-form .code-form-control.layout-3-column {
        width: 25%;
      }
      .code-form-control.layout-4-column,
      .contact-form .code-form-control.layout-4-column {
        width: 33.333%;
      }
      .code-form-control.layout-5-column,
      .contact-form .code-form-control.layout-5-column {
        width: 41.666%;
      }
      .code-form-control.layout-6-column,
      .contact-form .code-form-control.layout-6-column {
        width: 50%;
      }
      .code-form-control.layout-7-column,
      .contact-form .code-form-control.layout-7-column {
        width: 58.333%;
      }
      .code-form-control.layout-8-column,
      .contact-form .code-form-control.layout-8-column {
        width: 66.666%;
      }
      .code-form-control.layout-9-column,
      .contact-form .code-form-control.layout-9-column {
        width: 75%;
      }
      .code-form-control.layout-10-column,
      .contact-form .code-form-control.layout-10-column {
        width: 83.333%;
      }
      .code-form-control.layout-11-column,
      .contact-form .code-form-control.layout-11-column {
        width: 91.666%;
      }
      .code-form-control.layout-12-column,
      .contact-form .code-form-control.layout-12-column {
        width: 100%;
      }
    `;
    document.head.appendChild(styleElement);
  }
  
  // Function to apply additional styles after form loads
  function applyFormElementStyles(container) {
    if (!container) return;
    
    // Ensure file inputs are positioned correctly (overlay on upload area)
    const fileInputs = container.querySelectorAll('input[type="file"][data-type="file"]');
    fileInputs.forEach(function(input) {
      const uploadArea = input.closest('.upload-area');
      if (uploadArea) {
        input.style.position = 'absolute';
        input.style.width = '100%';
        input.style.height = '100%';
        input.style.top = '0';
        input.style.left = '0';
        input.style.opacity = '0';
        input.style.cursor = 'pointer';
        input.style.zIndex = '10';
      }
    });
    
    // Ensure upload areas have proper styling
    const uploadAreas = container.querySelectorAll('.upload-area');
    uploadAreas.forEach(function(area) {
      if (!area.style.minHeight) {
        area.style.minHeight = '150px';
      }
      if (!area.style.border || area.style.border === 'none') {
        area.style.border = '1px dashed #eb1256';
      }
      if (!area.style.display || area.style.display === 'none') {
        area.style.display = 'flex';
        area.style.flexDirection = 'column';
        area.style.alignItems = 'center';
        area.style.justifyContent = 'center';
      }
      area.style.position = 'relative';
    });
    
    // Ensure star rating fieldset displays horizontally
    const starRatings = container.querySelectorAll('.star-rating fieldset');
    starRatings.forEach(function(fieldset) {
      fieldset.style.display = 'flex';
      fieldset.style.flexDirection = 'row-reverse';
      fieldset.style.justifyContent = 'flex-end';
      fieldset.style.padding = '0';
      fieldset.style.margin = '0';
      fieldset.style.position = 'relative'; // Ensure fieldset is positioned for absolute children
    });
    
    // Ensure star rating inputs are clickable and properly positioned
    // With flex-direction: row-reverse, we need to position each input over its corresponding label
    // Use multiple attempts to ensure positioning works
    function positionStarInputs() {
      const starInputs = container.querySelectorAll('.star-rating fieldset input[type="radio"]');
      starInputs.forEach(function(input) {
        const inputId = input.getAttribute('id');
        const fieldset = input.closest('fieldset');
        if (!fieldset) return;
        
        const label = fieldset.querySelector('label[for="' + inputId + '"]');
        
        if (label) {
          // Get label's position relative to fieldset
          // Use offsetLeft/offsetTop for more reliable relative positioning
          let relativeLeft = label.offsetLeft;
          let relativeTop = label.offsetTop;
          
          // Fallback to getBoundingClientRect if offsetLeft/offsetTop don't work
          if (relativeLeft === 0 && relativeTop === 0) {
            const labelRect = label.getBoundingClientRect();
            const fieldsetRect = fieldset.getBoundingClientRect();
            relativeLeft = labelRect.left - fieldsetRect.left;
            relativeTop = labelRect.top - fieldsetRect.top;
          }
          
          const labelWidth = label.offsetWidth || 24;
          const labelHeight = label.offsetHeight || 24;
          
          // Position input directly over its label
          input.style.position = 'absolute';
          input.style.opacity = '0';
          input.style.width = labelWidth + 'px';
          input.style.height = labelHeight + 'px';
          input.style.margin = '0';
          input.style.padding = '0';
          input.style.cursor = 'pointer';
          input.style.zIndex = '10';
          input.style.pointerEvents = 'auto';
          input.style.top = relativeTop + 'px';
          input.style.left = relativeLeft + 'px';
        } else {
          // Fallback positioning
          input.style.position = 'absolute';
          input.style.opacity = '0';
          input.style.width = '1.5em';
          input.style.height = '1.5em';
          input.style.margin = '0';
          input.style.cursor = 'pointer';
          input.style.zIndex = '10';
          input.style.pointerEvents = 'auto';
        }
        
        // Ensure input is clickable and updates star display
        if (!input.hasAttribute('data-star-input-handler')) {
          input.setAttribute('data-star-input-handler', 'true');
          input.addEventListener('change', function() {
            updateStarRatingDisplay(this);
          });
          input.addEventListener('click', function(e) {
            e.stopPropagation();
            this.checked = true;
            updateStarRatingDisplay(this);
            const changeEvent = new Event('change', { bubbles: true });
            this.dispatchEvent(changeEvent);
          });
        }
      });
    }
    
    // Try positioning multiple times to ensure it works
    positionStarInputs();
    setTimeout(positionStarInputs, 50);
    setTimeout(positionStarInputs, 100);
    setTimeout(positionStarInputs, 200);
    setTimeout(positionStarInputs, 500);
    
    // Also set initial positioning without delay as fallback
    const starInputs = container.querySelectorAll('.star-rating fieldset input[type="radio"]');
    starInputs.forEach(function(input, index) {
      input.style.position = 'absolute';
      input.style.opacity = '0';
      input.style.width = '1.5em';
      input.style.height = '1.5em';
      input.style.margin = '0';
      input.style.cursor = 'pointer';
      input.style.zIndex = '10';
      input.style.pointerEvents = 'auto';
    });
    
    // Ensure star rating labels display horizontally and are clickable
    const starLabels = container.querySelectorAll('.star-rating fieldset label');
    starLabels.forEach(function(label) {
      label.style.width = '1.5em';
      label.style.padding = '0';
      label.style.margin = '0 2px';
      label.style.overflow = 'visible';
      label.style.flexShrink = '0';
      label.style.whiteSpace = 'nowrap';
      label.style.cursor = 'pointer';
      label.style.fontSize = '200%';
      label.style.color = 'rgba(0,0,0,0)';
      label.style.position = 'relative';
      label.style.display = 'block';
      label.style.pointerEvents = 'auto';
      label.style.background = 'transparent';
      
      // Initialize star state (empty by default)
      label.classList.add('star-empty');
      
      // Ensure label triggers input click - use once to avoid duplicates
      if (!label.hasAttribute('data-star-handler-attached')) {
        label.setAttribute('data-star-handler-attached', 'true');
        label.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          const inputId = this.getAttribute('for');
          if (!inputId) {
            return;
          }
          
          const input = document.getElementById(inputId);
          if (input && input.type === 'radio') {
            // Check the clicked one (browser will uncheck others automatically for radio groups)
            input.checked = true;
            
            // Update star display immediately
            updateStarRatingDisplay(input);
            
            // Force visual update by triggering change event
            const changeEvent = new Event('change', { bubbles: true });
            input.dispatchEvent(changeEvent);
          } else {
          }
        });
      }
    });
    
    // Initialize display for any pre-checked stars
    const checkedInputs = container.querySelectorAll('.star-rating fieldset input[type="radio"]:checked');
    checkedInputs.forEach(function(input) {
      updateStarRatingDisplay(input);
    });
    
    // Also check all inputs to ensure they have change handlers
    const allStarInputs = container.querySelectorAll('.star-rating fieldset input[type="radio"]');
    allStarInputs.forEach(function(input) {
      if (!input.hasAttribute('data-star-change-handler')) {
        input.setAttribute('data-star-change-handler', 'true');
        input.addEventListener('change', function() {
          updateStarRatingDisplay(this);
        });
        input.addEventListener('click', function(e) {
          e.stopPropagation();
          this.checked = true;
          updateStarRatingDisplay(this);
          const changeEvent = new Event('change', { bubbles: true });
          this.dispatchEvent(changeEvent);
        });
      }
    });
    
    // Ensure checkbox and radio wrappers use flex
    const checkboxWrappers = container.querySelectorAll('.checkbox-wrapper');
    checkboxWrappers.forEach(function(wrapper) {
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'center';
    });
    
    const radioWrappers = container.querySelectorAll('.radio-wrapper');
    radioWrappers.forEach(function(wrapper) {
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'center';
    });
    
    // Remove list markers from all list items - apply inline styles to ensure they work
    const allListItems = container.querySelectorAll('.code-form-control ul, .code-form-control li, .code-form-control .globo-list-control, .code-form-control ul li.globo-list-control');
    allListItems.forEach(function(item) {
      item.style.setProperty('list-style', 'none', 'important');
      item.style.setProperty('list-style-type', 'none', 'important');
      item.style.setProperty('list-style-image', 'none', 'important');
      item.style.setProperty('margin-left', '0', 'important');
      item.style.setProperty('padding-left', '0', 'important');
    });
    
    // Also remove from ul elements
    const allLists = container.querySelectorAll('.code-form-control ul, .code-form-control ul.flex-wrap');
    allLists.forEach(function(list) {
      list.style.setProperty('list-style', 'none', 'important');
      list.style.setProperty('list-style-type', 'none', 'important');
      list.style.setProperty('list-style-image', 'none', 'important');
      list.style.setProperty('margin-left', '0', 'important');
      list.style.setProperty('padding-left', '0', 'important');
    });
  }
  
  // Function to initialize file upload handlers
  function initializeFileUploadHandlers(container) {
    if (!container) return;
    
    // Prevent multiple initializations
    if (container.hasAttribute('data-file-handlers-initialized')) {
      return;
    }
    container.setAttribute('data-file-handlers-initialized', 'true');
    
    // Global flag to prevent double-triggering across all handlers
    let globalFileInputProcessing = false;
    
    // Handle file button clicks - prevent double-triggering
    container.querySelectorAll('.file_button').forEach(function(button) {
      // Remove existing listeners by cloning
      const newButton = button.cloneNode(true);
      if (button.parentNode) {
        button.parentNode.replaceChild(newButton, button);
      }
      
      newButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        
        if (globalFileInputProcessing) {
          return false;
        }
        globalFileInputProcessing = true;
        
        const uploadArea = this.closest('.upload-area');
        if (uploadArea) {
          const fileInput = uploadArea.querySelector('input[type="file"]');
          if (fileInput && !fileInput.disabled) {
            // Use setTimeout to ensure the click happens after event propagation stops
            setTimeout(function() {
              fileInput.click();
              // Reset flag after dialog would have opened
              setTimeout(function() {
                globalFileInputProcessing = false;
              }, 500);
            }, 10);
          } else {
            globalFileInputProcessing = false;
          }
        } else {
          globalFileInputProcessing = false;
        }
        
        return false;
      });
    });
    
    // Handle file input changes - use event delegation to avoid cloning issues
    container.addEventListener('change', function(e) {
      if (e.target && e.target.type === 'file' && e.target.getAttribute('data-type') === 'file') {
        const input = e.target;
        const uploadArea = input.closest('.upload-area');
        if (!uploadArea) return;
        
        const uploadText = uploadArea.querySelector('.upload-p, #uploadText, [id^="uploadText-"]');
        const fileButton = uploadArea.querySelector('.file_button, #fileButton, [id^="fileButton-"]');
        let imgContainer = uploadArea.querySelector('.img-container, #imgContainer, [id^="imgContainer-"]');
        
        // Create img-container if it doesn't exist
        if (!imgContainer) {
          imgContainer = document.createElement('div');
          imgContainer.className = 'img-container';
          imgContainer.id = 'imgContainer-' + (input.getAttribute('data-formdataid') || '');
          uploadArea.appendChild(imgContainer);
        }
        
        if (input.files && input.files.length > 0) {
          // Add class to upload area to hide text and button via CSS
          uploadArea.classList.add('has-files');
          
          // Hide upload text and button immediately with multiple methods
          if (uploadText) {
            uploadText.style.setProperty('display', 'none', 'important');
            uploadText.style.setProperty('visibility', 'hidden', 'important');
            uploadText.style.setProperty('opacity', '0', 'important');
            uploadText.style.setProperty('height', '0', 'important');
            uploadText.style.setProperty('width', '0', 'important');
            uploadText.style.setProperty('overflow', 'hidden', 'important');
            uploadText.style.setProperty('margin', '0', 'important');
            uploadText.style.setProperty('padding', '0', 'important');
            uploadText.setAttribute('hidden', 'true');
          }
          if (fileButton) {
            fileButton.style.setProperty('display', 'none', 'important');
            fileButton.style.setProperty('visibility', 'hidden', 'important');
            fileButton.style.setProperty('opacity', '0', 'important');
            fileButton.style.setProperty('height', '0', 'important');
            fileButton.style.setProperty('width', '0', 'important');
            fileButton.style.setProperty('overflow', 'hidden', 'important');
            fileButton.style.setProperty('margin', '0', 'important');
            fileButton.style.setProperty('padding', '0', 'important');
            fileButton.setAttribute('hidden', 'true');
          }
          
          // Clear existing content
          imgContainer.innerHTML = '';
          imgContainer.style.cssText = 'width: 100% !important; display: flex !important; flex-wrap: wrap !important; gap: 10px !important; justify-content: center !important; align-items: center !important; padding: 10px !important; min-height: 50px !important; position: relative !important; z-index: 5 !important; visibility: visible !important; opacity: 1 !important; box-sizing: border-box !important;';
          
          // Adjust upload area styling when files are present
          uploadArea.style.cssText = (uploadArea.getAttribute('style') || '') + '; justify-content: flex-start !important; min-height: auto !important; padding: 10px !important; overflow: visible !important; flex-direction: row !important; flex-wrap: wrap !important;';
          
          // Lower z-index of file input so preview shows above it
          input.style.zIndex = '1';
          input.style.pointerEvents = 'auto';
          
          // Show file names or previews
          Array.from(input.files).forEach(function(file, index) {
            const fileWrapper = document.createElement('div');
            fileWrapper.className = 'img-preview-wrapper';
            fileWrapper.style.cssText = 'position: relative; display: flex; flex-direction: column; align-items: center; margin: 5px; max-width: 200px; z-index: 3;';
            
            const fileName = document.createElement('p');
            fileName.className = 'file-name';
            fileName.textContent = file.name;
            fileName.style.cssText = 'margin: 5px 0 0 0; font-size: 12px; word-break: break-word; text-align: center; max-width: 100%; color: #333;';
            
            if (file.type && file.type.startsWith('image/')) {
              const reader = new FileReader();
              reader.onload = function(event) {
                const img = document.createElement('img');
                img.className = 'img-preview';
                img.src = event.target.result;
                img.setAttribute('style', 'width: 150px !important; max-width: 100% !important; max-height: 150px !important; height: auto !important; object-fit: contain !important; border: 1px solid #eb1256 !important; border-radius: 4px !important; background: #fff !important; display: block !important; margin: 0 auto !important;');
                img.alt = file.name;
                img.title = file.name;
                img.onerror = function() {
                  this.style.display = 'none';
                  if (fileName.parentNode) {
                    fileName.style.display = 'block';
                  }
                };
                
                // Create remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'img-remove-btn';
                removeBtn.type = 'button';
                removeBtn.innerHTML = '√ó';
                removeBtn.title = 'Remove image';
                removeBtn.setAttribute('aria-label', 'Remove image');
                removeBtn.onclick = function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  // Remove this file wrapper
                  fileWrapper.remove();
                  
                  // Check if there are any remaining files
                  const remainingWrappers = imgContainer.querySelectorAll('.img-preview-wrapper');
                  if (remainingWrappers.length === 0) {
                    // No files left, reset upload area
                    uploadArea.classList.remove('has-files');
                    
                    // Show upload text and button again
                    if (uploadText) {
                      uploadText.style.cssText = '';
                      uploadText.removeAttribute('style');
                      uploadText.removeAttribute('hidden');
                    }
                    if (fileButton) {
                      fileButton.style.cssText = '';
                      fileButton.removeAttribute('style');
                      fileButton.removeAttribute('hidden');
                    }
                    
                    // Reset upload area styling
                    uploadArea.style.justifyContent = 'center';
                    uploadArea.style.minHeight = '150px';
                    uploadArea.style.flexDirection = 'column';
                    uploadArea.style.overflow = 'hidden';
                    
                    // Clear file input
                    input.value = '';
                    input.style.zIndex = '10';
                  } else {
                    // Update file input to remove this file (for multiple files)
                    const dt = new DataTransfer();
                    Array.from(input.files).forEach(function(f, idx) {
                      if (idx !== index) {
                        dt.items.add(f);
                      }
                    });
                    input.files = dt.files;
                  }
                };
                
                fileWrapper.appendChild(img);
                fileWrapper.appendChild(removeBtn);
                fileWrapper.appendChild(fileName);
                imgContainer.appendChild(fileWrapper);
                
                // Force reflow to ensure visibility
                void imgContainer.offsetHeight;
              };
              reader.onerror = function() {
                // If image fails to load, show file name only
                fileWrapper.appendChild(fileName);
                imgContainer.appendChild(fileWrapper);
              };
              reader.readAsDataURL(file);
            } else {
              const folderIcon = document.createElement('div');
              folderIcon.style.cssText = 'width: 150px; height: 150px; background: #f0f0f0; border: 1px solid #eb1256; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 48px; position: relative;';
              folderIcon.textContent = 'üìÅ';
              folderIcon.title = file.name;
              
              // Create remove button for non-image files too
              const removeBtn = document.createElement('button');
              removeBtn.className = 'img-remove-btn';
              removeBtn.type = 'button';
              removeBtn.innerHTML = '√ó';
              removeBtn.title = 'Remove file';
              removeBtn.setAttribute('aria-label', 'Remove file');
              removeBtn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                // Remove this file wrapper
                fileWrapper.remove();
                
                // Check if there are any remaining files
                const remainingWrappers = imgContainer.querySelectorAll('.img-preview-wrapper');
                if (remainingWrappers.length === 0) {
                  // No files left, reset upload area
                  uploadArea.classList.remove('has-files');
                  
                  // Show upload text and button again
                  if (uploadText) {
                    uploadText.style.cssText = '';
                    uploadText.removeAttribute('style');
                    uploadText.removeAttribute('hidden');
                  }
                  if (fileButton) {
                    fileButton.style.cssText = '';
                    fileButton.removeAttribute('style');
                    fileButton.removeAttribute('hidden');
                  }
                  
                  // Reset upload area styling
                  uploadArea.style.justifyContent = 'center';
                  uploadArea.style.minHeight = '150px';
                  uploadArea.style.flexDirection = 'column';
                  uploadArea.style.overflow = 'hidden';
                  
                  // Clear file input
                  input.value = '';
                  input.style.zIndex = '10';
                } else {
                  // Update file input to remove this file (for multiple files)
                  const dt = new DataTransfer();
                  Array.from(input.files).forEach(function(f, idx) {
                    if (idx !== index) {
                      dt.items.add(f);
                    }
                  });
                  input.files = dt.files;
                }
              };
              
              fileWrapper.appendChild(folderIcon);
              fileWrapper.appendChild(removeBtn);
              fileWrapper.appendChild(fileName);
              imgContainer.appendChild(fileWrapper);
            }
          });
        } else {
          // Remove has-files class
          uploadArea.classList.remove('has-files');
          
          // Show upload text and button if no files
          if (uploadText) {
            uploadText.style.cssText = '';
            uploadText.removeAttribute('style');
          }
          if (fileButton) {
            fileButton.style.cssText = '';
            fileButton.removeAttribute('style');
          }
          if (imgContainer) {
            imgContainer.innerHTML = '';
            imgContainer.style.display = 'none';
          }
          // Reset upload area styling
          uploadArea.style.justifyContent = 'center';
          uploadArea.style.minHeight = '150px';
          uploadArea.style.flexDirection = 'column';
          uploadArea.style.overflow = 'hidden';
          input.style.zIndex = '10';
        }
      }
    }, true); // Use capture phase for event delegation
    
    // Make upload area clickable - prevent double-triggering
    container.querySelectorAll('.upload-area').forEach(function(area) {
      // Remove existing listeners by cloning
      const newArea = area.cloneNode(true);
      if (area.parentNode) {
        area.parentNode.replaceChild(newArea, area);
      }
      
      newArea.addEventListener('click', function(e) {
        // Don't trigger if clicking on button or existing content
        if (e.target.classList.contains('file_button') || 
            e.target.closest('.file_button') ||
            e.target.closest('.img-preview-wrapper') || 
            e.target.closest('.img-container') ||
            e.target.tagName === 'INPUT') {
          return;
        }
        
        if (globalFileInputProcessing) {
          return false;
        }
        globalFileInputProcessing = true;
        
        const fileInput = this.querySelector('input[type="file"]');
        if (fileInput && !fileInput.disabled) {
          // Use setTimeout to ensure the click happens after event propagation stops
          setTimeout(function() {
            fileInput.click();
            // Reset flag after dialog would have opened
            setTimeout(function() {
              globalFileInputProcessing = false;
            }, 500);
          }, 10);
        } else {
          globalFileInputProcessing = false;
        }
      });
      newArea.style.cursor = 'pointer';
    });
  }
  
  // Function to update star rating display when a star is selected
  function updateStarRatingDisplay(checkedInput) {
    const fieldset = checkedInput.closest('fieldset');
    if (!fieldset) return;
    
    // Get the checked value - use .value or getAttribute and ensure it's correct
    const checkedInputValue = parseInt(checkedInput.value || checkedInput.getAttribute('value')) || 0;
    
    // Debug: Log the checked value
    
    // Ensure we have a valid value
    if (checkedInputValue <= 0 || checkedInputValue > 5) {
      return;
    }
    
    const allInputs = Array.from(fieldset.querySelectorAll('input[type="radio"]'));
    
    // Get all inputs with their values
    // With flex-direction: row-reverse, the visual order is reversed from DOM order
    // DOM: [5, 4, 3, 2, 1] -> Visual: [1, 2, 3, 4, 5] (left to right)
    // The fill logic is simple: fill all stars where inputValue <= checkedValue
    const inputsArray = [];
    allInputs.forEach(function(input, index) {
      const value = parseInt(input.value || input.getAttribute('value')) || 0;
      if (value >= 1 && value <= 5) {
        inputsArray.push({
          input: input,
          value: value
        });
      }
    });
    
    
    // The checked value directly corresponds to how many stars to fill
    // If checkedValue = 5, fill all stars (values 1, 2, 3, 4, 5)
    // If checkedValue = 4, fill first 4 stars (values 1, 2, 3, 4)
    // This works because with flex-direction: row-reverse, value 1 is leftmost, value 5 is rightmost
    const checkedValue = checkedInputValue;
    
    // Now iterate through ALL inputs and fill based on value comparison
    inputsArray.forEach(function(item) {
      const input = item.input;
      const inputValue = item.value;
      const labelId = input.getAttribute('id');
      if (!labelId) {
        return;
      }
      
      let label = fieldset.querySelector('label[for="' + labelId + '"]');
      if (!label) {
        // Try finding label by input's next sibling
        label = input.nextElementSibling;
        if (!label || label.tagName !== 'LABEL') {
          return;
        }
      }
      
      // Remove existing classes
      label.classList.remove('star-filled', 'star-empty');
      
      // Fill stars if their value is <= checkedValue
      // Example: If clicking star 5 (checkedValue = 5), fill values 1, 2, 3, 4, 5
      // Simple and explicit: fill if inputValue <= checkedValue
      const shouldFill = (inputValue >= 1 && inputValue <= checkedValue && checkedValue >= 1 && checkedValue <= 5);
      
      
      if (shouldFill) {
        label.classList.add('star-filled');
        label.classList.remove('star-empty');
        label.setAttribute('data-star-state', 'filled');
        // Force reflow to ensure class is applied
        void label.offsetHeight;
        // Force style recalculation
        const computedStyle = window.getComputedStyle(label, ':before');
        void computedStyle.content;
      } else {
        label.classList.add('star-empty');
        label.classList.remove('star-filled');
        label.setAttribute('data-star-state', 'empty');
        // Force reflow to ensure class is applied
        void label.offsetHeight;
        // Force style recalculation
        const computedStyle = window.getComputedStyle(label, ':before');
        void computedStyle.content;
      }
    });
    
    // Force CSS re-evaluation
    void fieldset.offsetHeight;
  }
  
  // Function to fetch and apply design settings from customizer
  async function fetchAndApplyDesignSettings(formId, shop, container) {
    if (!formId || !container) return;
    
    try {
      // Get base URL for API calls
      let baseUrl = '';
      const scripts = document.querySelectorAll('script[src]');
      for (let i = 0; i < scripts.length; i++) {
        const src = scripts[i].src;
        if (src.indexOf('/form_builder/') > -1) {
          baseUrl = src.substring(0, src.indexOf('/form_builder/') + '/form_builder'.length);
          break;
        }
      }
      if (!baseUrl) {
        baseUrl = 'https://codelocksolutions.com/form_builder';
      }
      
      // Fetch design settings from API
      const designSettingsUrl = baseUrl + '/user/ajax_call.php';
      const formData = new FormData();
      formData.append('routine_name', 'get_form_design_settings');
      formData.append('form_id', formId);
      formData.append('store', shop);
      
      const response = await fetch(designSettingsUrl, {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        return;
      }
      
      const resultText = await response.text();
      let result;
      try {
        result = JSON.parse(resultText);
      } catch(e) {
        // Try to parse as JSON if it's wrapped
        try {
          result = JSON.parse(resultText);
        } catch(e2) {
          return;
        }
      }
      
      // Handle different response formats
      let designSettings = null;
      let elementDataMap = null;
      
      if (result && result.result === 'success') {
        // Check if settings are in result.settings or result.data
        if (result.settings && typeof result.settings === 'object') {
          designSettings = result.settings;
        } else if (result.data && typeof result.data === 'object') {
          designSettings = result.data;
        }
        
        // Get element_data if available
        if (result.element_data && typeof result.element_data === 'object') {
          elementDataMap = result.element_data;
        }
      }
      
      // Apply element data settings (layout, options per line, etc.)
      if (elementDataMap && typeof elementDataMap === 'object') {
        Object.keys(elementDataMap).forEach(function(key) {
          if (key.startsWith('element_')) {
            const formDataId = key.replace('element_', '');
            const elementInfo = elementDataMap[key];
            
            if (elementInfo && elementInfo.data && Array.isArray(elementInfo.data)) {
              applyElementDataSettings(container, formDataId, elementInfo.element_id, elementInfo.data);
            }
          }
        });
      }
      
      // Apply design settings (font size, color, border radius, etc.)
      if (designSettings && typeof designSettings === 'object') {
        Object.keys(designSettings).forEach(function(key) {
          if (key.startsWith('element_')) {
            const formDataId = key.replace('element_', '');
            const settings = designSettings[key];
            
            if (settings && typeof settings === 'object') {
              applyElementDesignSettings(container, formDataId, settings);
            }
          }
        });
      }
    } catch(error) {
    }
  }
  
  // Function to apply design settings to a specific element
  function applyElementDesignSettings(container, formDataId, settings) {
    if (!container || !formDataId || !settings) return;
    
    // Find all elements with this form_data_id
    const elements = container.querySelectorAll('[data-formdataid="' + formDataId + '"]');
    
    elements.forEach(function(element) {
      // Apply font size
      if (settings.fontSize !== undefined && settings.fontSize !== null) {
        const fontSize = parseInt(settings.fontSize) || 16;
        element.style.fontSize = fontSize + 'px';
        
        // Also apply to input, textarea, select elements inside
        const inputs = element.querySelectorAll('input, textarea, select, .classic-input');
        inputs.forEach(function(input) {
          input.style.fontSize = fontSize + 'px';
        });
        
        // Apply to file button
        const fileButton = element.querySelector('.file_button');
        if (fileButton) {
          fileButton.style.fontSize = fontSize + 'px';
        }
      }
      
      // Apply font weight
      if (settings.fontWeight !== undefined && settings.fontWeight !== null) {
        const fontWeight = settings.fontWeight || '400';
        element.style.fontWeight = fontWeight;
        const inputs = element.querySelectorAll('input, textarea, select, .classic-input');
        inputs.forEach(function(input) {
          input.style.fontWeight = fontWeight;
        });
        
        // Apply to file button
        const fileButton = element.querySelector('.file_button');
        if (fileButton) {
          fileButton.style.fontWeight = fontWeight;
        }
      }
      
      // Apply color
      if (settings.color && settings.color !== '') {
        element.style.color = settings.color;
        const inputs = element.querySelectorAll('input, textarea, select, .classic-input, label, .label-content, .upload-p');
        inputs.forEach(function(input) {
          input.style.color = settings.color;
        });
        
        // Apply to file button
        const fileButton = element.querySelector('.file_button');
        if (fileButton) {
          fileButton.style.color = settings.color;
        }
      }
      
      // Apply border radius
      if (settings.borderRadius !== undefined && settings.borderRadius !== null) {
        const borderRadius = parseInt(settings.borderRadius) || 4;
        const inputs = element.querySelectorAll('input, textarea, select, .classic-input');
        inputs.forEach(function(input) {
          input.style.borderRadius = borderRadius + 'px';
        });
        
        // Apply to upload area and file button
        const uploadArea = element.querySelector('.upload-area');
        if (uploadArea) {
          uploadArea.style.borderRadius = borderRadius + 'px';
        }
        const fileButton = element.querySelector('.file_button');
        if (fileButton) {
          fileButton.style.borderRadius = borderRadius + 'px';
        }
      }
      
      // Apply background color
      if (settings.bgColor && settings.bgColor !== '') {
        const inputs = element.querySelectorAll('input, textarea, select, .classic-input');
        inputs.forEach(function(input) {
          input.style.backgroundColor = settings.bgColor;
        });
        
        // Apply to upload area
        const uploadArea = element.querySelector('.upload-area');
        if (uploadArea) {
          uploadArea.style.backgroundColor = settings.bgColor;
        }
      }
    });
  }
  
  // Function to apply element data settings (layout, options per line, etc.)
  function applyElementDataSettings(container, formDataId, elementId, elementData) {
    if (!container || !formDataId || !elementData || !Array.isArray(elementData)) return;
    
    // Find all elements with this form_data_id
    const elements = container.querySelectorAll('[data-formdataid="' + formDataId + '"]');
    
    elements.forEach(function(element) {
      // Element ID 11 = Checkbox (element_type6)
      // Element ID 13 = Radio Button (element_type8)
      // Both use element_data[8] for "number of options per line"
      // Checkbox: array($label, $checkboxoption, $defaultvalue, $description, $hidelabel, $keeppossitionlabel, $required, $required__hidelabel, $noperline, $columnwidth)
      // Radio: array($label, $radiooption, $defaultselect, $description, $hidelabel, $keeppossitionlabel, $required, $required__hidelabel, $noperline, $columnwidth)
      const elementIdNum = parseInt(elementId) || 0;
      
      if (elementIdNum == 11 || elementIdNum == 13) {
        // Get number of options per line (index 8)
        const optionsPerLine = elementData[8] ? String(elementData[8]) : '1';
        
        // Find all list items (li) within this element
        const listItems = element.querySelectorAll('li.globo-list-control');
        listItems.forEach(function(li) {
          // Remove existing option-*-column classes
          li.className = li.className.replace(/\boption-\d+-column\b/g, '');
          // Add the correct class
          li.classList.add('option-' + optionsPerLine + '-column');
        });
      }
      
      // Apply column width
      // Checkbox (11): index 9
      // Radio (13): index 9
      // File (10): index 10
      // Rating Star (15): index 6
      // Others vary
      let columnWidthIndex = -1;
      if (elementIdNum == 11) { // Checkbox
        columnWidthIndex = 9;
      } else if (elementIdNum == 13) { // Radio
        columnWidthIndex = 9;
      } else if (elementIdNum == 10) { // File
        columnWidthIndex = 10;
      } else if (elementIdNum == 15) { // Rating Star
        columnWidthIndex = 6;
      } else if (elementIdNum == 1 || elementIdNum == 2 || elementIdNum == 3 || elementIdNum == 4 || elementIdNum == 5 || elementIdNum == 7 || elementIdNum == 20 || elementIdNum == 21 || elementIdNum == 22 || elementIdNum == 23) {
        columnWidthIndex = 9;
      } else if (elementIdNum == 9) { // Country/Dropdown
        columnWidthIndex = 12;
      }
      
      if (columnWidthIndex >= 0 && elementData[columnWidthIndex] !== undefined && elementData[columnWidthIndex] !== null) {
        const columnWidth = String(elementData[columnWidthIndex]);
        // Remove existing layout-*-column class
        element.className = element.className.replace(/\blayout-\d+-column\b/g, '');
        // Add the correct layout class
        element.classList.add('layout-' + columnWidth + '-column');
      }
    });
  }

  async function initializeFormBuilder() {
    // Inject CSS styles first
    injectFormStyles();
    
    const blockContainer = document.getElementById("easy-form-{{ block.id }}");
    
    if (!blockContainer) {
      return false;
    }
    
    // Get Form ID from block settings
    const formId = "{{ block.settings.form_id }}";
    
    // Validate Form ID (check for empty or default "0")
    if (!formId || formId.trim() === '' || formId.trim() === '0') {
      blockContainer.innerHTML = '<div style="padding: 20px; color: #d32f2f; text-align: center; border: 2px solid #d32f2f; border-radius: 4px; background: #ffebee;">' +
        '<strong>‚ö†Ô∏è Form ID Required</strong><br>' +
        'Please enter a Form ID in the block settings to display the form.' +
        '</div>';
      return false;
    }
    
    // Try different shop domain formats - Shopify might use different formats
    let shop = "{{ shop.permanent_domain }}";
    if (!shop || shop === "") {
      shop = "{{ shop.myshopify_domain }}";
    }
    if (!shop || shop === "") {
      shop = "{{ shop.domain }}";
    }
    // Fallback: try to get from window.location if available
    if (!shop || shop === "") {
      try {
        const hostname = window.location.hostname;
        if (hostname && hostname.includes('.myshopify.com')) {
          shop = hostname;
        }
      } catch(e) {
      }
    }
    
    // Load the form from app proxy
    try {
      const loadingDiv = blockContainer.querySelector('.form-loading');
      if (loadingDiv) {
        loadingDiv.innerHTML = '<div style="text-align: center; padding: 20px;">Loading form...</div>';
      } else {
        blockContainer.innerHTML = '<div style="text-align: center; padding: 20px;">Loading form...</div>';
      }
      
      const renderUrl = `/apps/easy-form-builder/render?form_id=${encodeURIComponent(formId)}&shop=${encodeURIComponent(shop)}`;
      
      const formResponse = await fetch(renderUrl, {
        method: 'GET',
        headers: {
          'Accept': 'text/html',
          'Content-Type': 'text/html'
        },
        credentials: 'same-origin'
      });
      
      if (!formResponse.ok) {
        // If 404, form doesn't exist - show error
        if (formResponse.status === 404) {
          throw new Error(`Failed to load form: ${formResponse.status} ${formResponse.statusText}`);
        } else {
          // For other errors, also show error
          throw new Error(`Failed to load form: ${formResponse.status} ${formResponse.statusText}`);
        }
      }
      
      const formHtml = await formResponse.text();
      
      // If form HTML is empty (form is disabled), hide the container
      if (!formHtml || formHtml.trim().length === 0) {
        blockContainer.style.display = 'none';
        return false;
      }
      
      if (formHtml && formHtml.trim().length > 0) {
        try {
          // Basic HTML sanitization - only remove clearly malformed content
          let sanitizedHtml = formHtml;
          
          // Remove only clearly malformed tags (not valid scripts)
          sanitizedHtml = sanitizedHtml.replace(/<if\b[^>]*>/gi, ''); // Remove stray <if> tags
          sanitizedHtml = sanitizedHtml.replace(/<endif\b[^>]*>/gi, ''); // Remove stray <endif> tags
          
          // Extract and execute scripts separately (innerHTML doesn't execute script tags)
          const tempDiv = document.createElement('div');
          
          // Try to set innerHTML with error handling
          try {
            tempDiv.innerHTML = sanitizedHtml;
          } catch(htmlError) {
            // If innerHTML fails, try to clean it more aggressively
            sanitizedHtml = sanitizedHtml.replace(/<[^>]*$/gm, ''); // Remove incomplete tags at end of lines
            try {
              tempDiv.innerHTML = sanitizedHtml;
            } catch(secondError) {
              // If still fails, try inserting without scripts
              sanitizedHtml = sanitizedHtml.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
              tempDiv.innerHTML = sanitizedHtml;
            }
          }
          
          // Extract all script tags - with comprehensive error handling
          const scripts = tempDiv.querySelectorAll('script');
          const scriptsToExecute = [];
          
          scripts.forEach(function(oldScript, scriptIdx) {
            try {
              let scriptContent = oldScript.textContent || oldScript.innerHTML || '';
              
              // Skip empty scripts
              if (!scriptContent || !scriptContent.trim()) {
                oldScript.remove();
                return;
              }
              
              // Clean up script content
              scriptContent = scriptContent.trim();
              
              // Remove any HTML tags that might have leaked into script
              scriptContent = scriptContent.replace(/<[^>]*>/g, '');
              
              // Only skip if clearly malformed (very strict criteria)
              const openBraces = (scriptContent.match(/\{/g) || []).length;
              const closeBraces = (scriptContent.match(/\}/g) || []).length;
              const openParens = (scriptContent.match(/\(/g) || []).length;
              const closeParens = (scriptContent.match(/\)/g) || []).length;
              
              // Only skip if severely mismatched (more than 5 difference)
              if (Math.abs(openBraces - closeBraces) > 5 || Math.abs(openParens - closeParens) > 5) {
                oldScript.remove();
                return;
              }
              
              // Store script for execution
              const scriptData = {
                content: scriptContent,
                attributes: {}
              };
              
              // Copy attributes
              Array.from(oldScript.attributes).forEach(function(attr) {
                try {
                  scriptData.attributes[attr.name] = attr.value;
                } catch(attrError) {
                  // Skip invalid attributes
                }
              });
              
              scriptsToExecute.push(scriptData);
              oldScript.remove();
            } catch(scriptError) {
              try {
                oldScript.remove();
              } catch(e) {
                // Ignore
              }
            }
          });
          
          // Inject critical CSS for form elements BEFORE inserting HTML
          injectFormStyles();
          
          // Insert HTML FIRST (before scripts) so form is visible
          try {
            blockContainer.innerHTML = tempDiv.innerHTML;
            // Clear loading message
            const loadingDiv = blockContainer.querySelector('.form-loading');
            if (loadingDiv) {
              loadingDiv.remove();
            }
          } catch(insertError) {
            // If insertion fails, try to insert a cleaned version
            const cleanedHtml = tempDiv.innerHTML.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            blockContainer.innerHTML = cleanedHtml;
            // Clear loading message
            const loadingDiv = blockContainer.querySelector('.form-loading');
            if (loadingDiv) {
              loadingDiv.remove();
            }
          }
          
          // Execute scripts AFTER HTML is inserted
          scriptsToExecute.forEach(function(scriptData, idx) {
            try {
              const newScript = document.createElement('script');
              
              // Set attributes
              Object.keys(scriptData.attributes).forEach(function(attrName) {
                try {
                  newScript.setAttribute(attrName, scriptData.attributes[attrName]);
                } catch(attrError) {
                  // Skip invalid attributes
                }
              });
              
              // Set script content
              newScript.textContent = scriptData.content;
              
              // Try multiple methods to execute script
              try {
                document.head.appendChild(newScript);
              } catch(appendError) {
                // Try document fragment
                try {
                  const fragment = document.createDocumentFragment();
                  fragment.appendChild(newScript);
                  document.head.appendChild(fragment);
                } catch(fragmentError) {
                  // Try eval as last resort (only for inline scripts)
                  if (!scriptData.attributes.src) {
                    try {
                      eval(scriptData.content);
                    } catch(evalError) {
                      // Silent fail - script was malformed
                    }
                  }
                }
              }
            } catch(execError) {
              // Silent fail for this script
            }
          });
          
          // Apply styles after form is loaded
          setTimeout(function() {
            applyFormElementStyles(blockContainer);
            initializeFileUploadHandlers(blockContainer);
            // Fetch and apply design settings from customizer
            fetchAndApplyDesignSettings(formId, shop, blockContainer);
          }, 200);
        } catch(mainError) {
          // If all else fails, show error message
          blockContainer.innerHTML = '<div style="padding: 20px; color: #d32f2f; text-align: center; border: 2px solid #d32f2f; border-radius: 4px; background: #ffebee;">' +
            '<strong>‚ö†Ô∏è Error Loading Form</strong><br>' +
            'There was an error loading the form. Please try refreshing the page.' +
            '</div>';
          return false;
        }
        
        // Remove readonly/disabled attributes from form fields so users can type
        const formInputs = blockContainer.querySelectorAll('input, textarea, select');
        formInputs.forEach(function(input, idx) {
          const name = input.name || input.getAttribute('name') || 'NO_NAME';
          const hadReadonly = input.hasAttribute('readonly');
          const wasDisabled = input.disabled;
          const hasTabindex = input.hasAttribute('tabindex');
          const tabindexValue = hasTabindex ? input.getAttribute('tabindex') : null;
          
          
          // Remove readonly
          if (hadReadonly) {
            input.removeAttribute('readonly');
          }
          
          // Enable disabled inputs
          if (wasDisabled) {
            input.disabled = false;
          }
          
          // Remove negative tabindex (which prevents keyboard focus)
          if (hasTabindex && tabindexValue === '-1') {
            input.removeAttribute('tabindex');
          }
          
          // Ensure input is focusable and editable
          input.style.pointerEvents = 'auto';
          input.style.userSelect = 'auto';
          
          // Verify the input is now editable
        });
        
        // Also use MutationObserver to catch any dynamically added readonly attributes
        if (typeof MutationObserver !== 'undefined') {
          const attrObserver = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
              if (mutation.type === 'attributes' && (mutation.attributeName === 'readonly' || mutation.attributeName === 'disabled')) {
                const target = mutation.target;
                if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT') {
                  if (target.hasAttribute('readonly')) {
                    target.removeAttribute('readonly');
                  }
                  if (target.disabled) {
                    target.disabled = false;
                  }
                }
              }
            });
          });
          
          formInputs.forEach(function(input) {
            attrObserver.observe(input, {
              attributes: true,
              attributeFilter: ['readonly', 'disabled']
            });
          });
          
        }
        
        // Initialize form fill tracking (track when user clicks/focuses on any input)
        initializeFormFillTracking();
        
        // Initialize form submission handler
        initializeFormSubmission();
        // Initialize button hover effects
        initializeButtonHoverEffects();
        // Initialize floating form functionality
        initializeFloatingForm();
      } else {
        // Empty form HTML - form is disabled, hide the container
        blockContainer.style.display = 'none';
        return false;
      }
    } catch (error) {
      // Only show error if it's a real error (not just empty form)
      // Check if error message indicates form is disabled
      if (error.message && error.message.includes('Empty form HTML')) {
        blockContainer.style.display = 'none';
        return false;
      }
      
      // Only show error for actual errors (404, 500, etc.), not for disabled forms
      if (error.message && !error.message.includes('Empty form HTML')) {
        blockContainer.innerHTML = '<div style="padding: 20px; color: #d32f2f; text-align: center; border: 2px solid #d32f2f; border-radius: 4px; background: #ffebee;">' +
          '<strong>Error loading form</strong><br>' +
          error.message + '<br>' +
          '<small>Please check that the Form ID is correct and the form exists in your app.</small>' +
          '</div>';
      } else {
        // Form is disabled - just hide it
        blockContainer.style.display = 'none';
      }
    }
  }
  
  // Function to show inline notification messages (replaces alerts)
  function showNotification(message, type) {
    type = type || 'success'; // 'success' or 'error'
    const blockContainer = document.getElementById("easy-form-{{ block.id }}");
    if (!blockContainer) {
      // Fallback to alert if container not found
      // Silent fail
      return;
    }
    
    // Remove any existing notifications
    const existingNotification = blockContainer.querySelector('.form-notification');
    if (existingNotification) {
      existingNotification.remove();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = 'form-notification form-notification-' + type;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: ${type === 'success' ? '#4caf50' : '#f44336'};
      color: white;
      padding: 16px 24px;
      border-radius: 4px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 10000;
      font-size: 16px;
      font-weight: 500;
      max-width: 400px;
      animation: slideIn 0.3s ease-out;
    `;
    notification.textContent = message;
    
    // Add animation styles if not already added
    if (!document.getElementById('form-notification-styles')) {
      const style = document.createElement('style');
      style.id = 'form-notification-styles';
      style.textContent = `
        @keyframes slideIn {
          from {
            transform: translateX(100%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        @keyframes slideOut {
          from {
            transform: translateX(0);
            opacity: 1;
          }
          to {
            transform: translateX(100%);
            opacity: 0;
          }
        }
        .form-notification {
          animation: slideIn 0.3s ease-out;
        }
        .form-notification.hiding {
          animation: slideOut 0.3s ease-out;
        }
      `;
      document.head.appendChild(style);
    }
    
    // Insert notification
    document.body.appendChild(notification);
    
    // Auto-dismiss after 3 seconds for success, 5 seconds for error
    const dismissTime = type === 'success' ? 3000 : 5000;
    setTimeout(function() {
      notification.classList.add('hiding');
      setTimeout(function() {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, dismissTime);
    
    // Also allow manual dismiss on click
    notification.style.cursor = 'pointer';
    notification.addEventListener('click', function() {
      notification.classList.add('hiding');
      setTimeout(function() {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    });
  }
  
  function initializeFormFillTracking() {
    const blockContainer = document.getElementById("easy-form-{{ block.id }}");
    if (!blockContainer) {
      return;
    }
    
    // Try multiple selectors to find the form
    let forms = blockContainer.querySelectorAll('form.get_selected_elements');
    if (forms.length === 0) {
      forms = blockContainer.querySelectorAll('form');
    }
    if (forms.length === 0) {
      // Try to find form by looking for form_id input
      const formIdInputs = blockContainer.querySelectorAll('input[name="form_id"], input.form_id');
      if (formIdInputs.length > 0) {
        forms = Array.from(formIdInputs).map(function(input) {
          return input.closest('form');
        }).filter(function(form) {
          return form !== null;
        });
      }
    }
    
    if (forms.length === 0) {
      setTimeout(function() {
        initializeFormFillTracking();
      }, 500);
      return;
    }
    
    forms.forEach(function(form, index) {
      // Get form ID - try multiple methods
      let formId = '';
      
      // Method 1: Look for hidden input with form_id
      const formIdInput = form.querySelector('input[name="form_id"], input.form_id');
      if (formIdInput) {
        formId = formIdInput.value || '';
      }
      
      // Method 2: Check data attribute
      if (!formId) {
        formId = form.getAttribute('data-id') || form.getAttribute('data-form-id') || '';
      }
      
      // Method 3: Check block container
      if (!formId && blockContainer) {
        formId = blockContainer.getAttribute('data-form-id') || '';
      }
      
      // Method 4: Get from block settings (fallback)
      if (!formId) {
        formId = "{{ block.settings.form_id }}" || '';
      }
      
      if (!formId || formId.trim() === '' || formId.trim() === '0') {
        return;
      }
      
      // Get shop domain
      let shop = "{{ shop.permanent_domain }}";
      if (!shop || shop === "") {
        shop = "{{ shop.myshopify_domain }}";
      }
      if (!shop || shop === "") {
        shop = "{{ shop.domain }}";
      }
      if (!shop || shop === "") {
        const hostname = window.location.hostname;
        if (hostname && hostname.includes('.myshopify.com')) {
          shop = hostname;
        }
      }
      
      if (!shop) {
        return;
      }
      
      // Track fill only once per form view (use data attribute to prevent multiple tracks)
      let fillTracked = form.getAttribute('data-fill-tracked');
      if (fillTracked === 'true') {
        return; // Already tracked
      }
      
      // Get all form inputs (input, textarea, select)
      const formInputs = form.querySelectorAll('input, textarea, select');
      
      // Track fill when user focuses or clicks on any input
      const trackFill = function(event) {
        // Check if already tracked
        if (form.getAttribute('data-fill-tracked') === 'true') {
          return; // Already tracked
        }
        
        // Mark as tracked immediately to prevent duplicate tracking
        form.setAttribute('data-fill-tracked', 'true');
        
        // Send AJAX request to track fill
        const formData = new FormData();
        formData.append('store', shop);
        formData.append('routine_name', 'trackFormFill');
        formData.append('form_id', formId);
        
        // Get base URL - try multiple methods
        let baseUrl = '';
        
        // Method 1: Try to get from script tags
        const scripts = document.querySelectorAll('script[src]');
        for (let i = 0; i < scripts.length; i++) {
          const src = scripts[i].src;
          if (src.indexOf('/form_builder/') > -1) {
            baseUrl = src.substring(0, src.indexOf('/form_builder/') + '/form_builder'.length);
            break;
          }
        }
        
        // Method 2: Try to get from current page URL
        if (!baseUrl) {
          const currentUrl = window.location.href;
          if (currentUrl.indexOf('/form_builder/') > -1) {
            baseUrl = currentUrl.substring(0, currentUrl.indexOf('/form_builder/') + '/form_builder'.length);
          }
        }
        
        // Method 3: Default to production URL
        if (!baseUrl) {
          baseUrl = 'https://codelocksolutions.com/form_builder';
        }
        
        const ajaxUrl = baseUrl + '/user/ajax_call.php';
        
        fetch(ajaxUrl, {
          method: 'POST',
          body: formData
        })
        .then(function(response) {
          if (!response.ok) {
            throw new Error('HTTP error! status: ' + response.status);
          }
          return response.json();
        })
        .then(function(data) {
          // Silent success
        })
        .catch(function(error) {
          // Silent error
        });
      };
      
      // Attach event listeners to all inputs
      formInputs.forEach(function(input) {
        // Skip hidden inputs and submit buttons
        if (input.type === 'hidden' || input.type === 'submit' || input.type === 'button') {
          return;
        }
        
        // Track on focus (when user clicks into the field)
        input.addEventListener('focus', function(e) {
          trackFill(e);
        }, { once: true });
        
        // Also track on click (in case focus doesn't fire)
        input.addEventListener('click', function(e) {
          trackFill(e);
        }, { once: true });
        
        // Also track on input (when user starts typing)
        input.addEventListener('input', function(e) {
          trackFill(e);
        }, { once: true });
      });
    });
  }
  
  function initializeFormSubmission() {
    const blockContainer = document.getElementById("easy-form-{{ block.id }}");
    if (!blockContainer) return;
    
    const forms = blockContainer.querySelectorAll('form.get_selected_elements');
    
    forms.forEach(function(form, index) {
      
      // Get form ID
      const formIdInput = form.querySelector('input[name="form_id"], input.form_id');
      const formId = formIdInput ? formIdInput.value : form.getAttribute('data-id') || '';
      if (!formId) {
        return;
      }
      
      // Get shop domain
      let shop = "{{ shop.permanent_domain }}";
      if (!shop || shop === "") {
        shop = "{{ shop.myshopify_domain }}";
      }
      if (!shop || shop === "") {
        shop = "{{ shop.domain }}";
      }
      if (!shop || shop === "") {
        const hostname = window.location.hostname;
        if (hostname && hostname.includes('.myshopify.com')) {
          shop = hostname;
        }
      }
      
      // Form submit handler
      function handleFormSubmit(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Log all form inputs BEFORE modifying
        const allInputs = form.querySelectorAll('input, textarea, select');
        allInputs.forEach(function(input, idx) {
          const name = input.name || input.getAttribute('name') || 'NO_NAME';
          const value = input.value || input.getAttribute('value') || '';
          const type = input.type || input.tagName.toLowerCase();
          const disabled = input.disabled;
        });
        
        // Remove readonly/disabled attributes temporarily to ensure values are collected
        const readonlyInputs = form.querySelectorAll('input[readonly], textarea[readonly]');
        const disabledInputs = form.querySelectorAll('input[disabled], textarea[disabled]');
        const readonlyStates = [];
        const disabledStates = [];
        
        // Store and remove readonly
        readonlyInputs.forEach(function(input) {
          readonlyStates.push({element: input, name: input.name});
          input.removeAttribute('readonly');
        });
        
        // Store and enable disabled inputs
        disabledInputs.forEach(function(input) {
          disabledStates.push({element: input, name: input.name});
          input.disabled = false;
        });
        
        // Check if any values exist
        let hasAnyValue = false;
        allInputs.forEach(function(input, idx) {
          const value = input.value || input.getAttribute('value') || '';
          if (value.trim().length > 0) {
            hasAnyValue = true;
          }
        });
        
        // Warn if no values found
        if (!hasAnyValue) {
          // Test if we can set values programmatically
          allInputs.forEach(function(input, idx) {
            const testValue = 'TEST_VALUE_' + idx;
            const oldValue = input.value;
            input.value = testValue;
            // Restore old value
            input.value = oldValue;
          });
          
          // Show error notification
          showNotification('Error: Form fields appear to be empty. Please fill out the form before submitting.', 'error');
          return false; // Stop submission
        }
        
        // Create FormData AFTER removing readonly/disabled
        const formData = new FormData(form);
        
        // Restore readonly/disabled states immediately
        readonlyStates.forEach(function(state) {
          state.element.setAttribute('readonly', 'readonly');
        });
        disabledStates.forEach(function(state) {
          state.element.disabled = true;
        });
        
        // Add system fields
        formData.append('store', shop);
        formData.append('routine_name', 'addformdata');
        formData.append('form_id', formId);
        
        // Log FormData entries
        const formDataEntries = Array.from(formData.entries());
        formDataEntries.forEach(function(entry, idx) {
        });
        
        // Verify we have actual form data (not just system fields)
        const formFieldNames = [];
        formDataEntries.forEach(function(entry) {
          const key = entry[0];
          if (key !== 'store' && key !== 'routine_name' && key !== 'form_id' && key !== 'id') {
            formFieldNames.push(key);
          }
        });
        
        if (formFieldNames.length === 0) {
          showNotification('Error: Form fields not found. Please check form configuration.', 'error');
          return false;
        }
        
        // Disable submit button
        const submitBtn = form.querySelector('button.submit, .submit.action, .footer-data__submittext, button[type="submit"], .action.submit');
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.style.opacity = '0.6';
          const originalText = submitBtn.innerHTML;
          submitBtn.setAttribute('data-original-text', originalText);
          submitBtn.innerHTML = 'Submitting...';
        }
        
        // Get AJAX URL
        const ajaxUrl = 'https://codelocksolutions.com/form_builder/user/ajax_call.php';
        
        // Submit via fetch
        
        fetch(ajaxUrl, {
          method: 'POST',
          body: formData
        })
        .then(function(response) {
          return response.text();
        })
        .then(function(responseText) {
          let data;
          try {
            data = JSON.parse(responseText);
          } catch(e) {
            throw new Error('Invalid JSON response: ' + responseText.substring(0, 200));
          }
          
          if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.style.opacity = '1';
            const originalText = submitBtn.getAttribute('data-original-text');
            if (originalText) {
              submitBtn.innerHTML = originalText;
            }
          }
          
          if (data.result === 'success') {
            showNotification(data.msg || 'Form submitted successfully!', 'success');
            
            // Custom form reset to handle star ratings and file uploads
            form.reset();
            
            // Clear star ratings
            const starInputs = form.querySelectorAll('.star-rating input[type="radio"]');
            starInputs.forEach(function(input) {
              input.checked = false;
              const fieldset = input.closest('fieldset');
              if (fieldset) {
                const labels = fieldset.querySelectorAll('label');
                labels.forEach(function(label) {
                  label.classList.remove('star-filled');
                  label.classList.add('star-empty');
                  label.removeAttribute('data-star-state');
                });
              }
            });
            
            // Clear file upload previews
            const uploadAreas = form.querySelectorAll('.upload-area');
            uploadAreas.forEach(function(uploadArea) {
              // Remove has-files class
              uploadArea.classList.remove('has-files');
              
              const imgContainer = uploadArea.querySelector('.img-container, #imgContainer, [id^="imgContainer-"]');
              if (imgContainer) {
                imgContainer.innerHTML = '';
                imgContainer.style.display = 'none';
              }
              
              // Show upload text and button again
              const uploadText = uploadArea.querySelector('.upload-p, #uploadText, [id^="uploadText-"]');
              const fileButton = uploadArea.querySelector('.file_button, #fileButton, [id^="fileButton-"]');
              if (uploadText) {
                uploadText.style.cssText = '';
                uploadText.removeAttribute('style');
              }
              if (fileButton) {
                fileButton.style.cssText = '';
                fileButton.removeAttribute('style');
              }
              
              // Reset upload area styling
              uploadArea.style.justifyContent = 'center';
              uploadArea.style.minHeight = '150px';
              uploadArea.style.flexDirection = 'column';
              uploadArea.style.overflow = 'hidden';
              
              // Reset file input
              const fileInput = uploadArea.querySelector('input[type="file"]');
              if (fileInput) {
                fileInput.value = '';
                fileInput.style.zIndex = '10';
              }
            });
          } else {
            showNotification(data.msg || 'Something went wrong. Please try again.', 'error');
          }
        })
        .catch(function(error) {
          if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.style.opacity = '1';
            const originalText = submitBtn.getAttribute('data-original-text');
            if (originalText) {
              submitBtn.innerHTML = originalText;
            }
          }
          showNotification('An error occurred. Please try again.', 'error');
        });
        
        return false;
      }
      
      // Attach submit handler to form
      form.addEventListener('submit', handleFormSubmit);
      
      // Also attach to submit buttons - search more broadly
      // First try within form
      let submitButtons = form.querySelectorAll('button.submit, .submit.action, .footer-data__submittext, button[type="submit"], .action.submit, button.action.submit.classic-button, button.action.submit, .action.submit.classic-button.footer-data__submittext');
      
      // If none found, search in the block container (button might be outside form)
      if (submitButtons.length === 0) {
        submitButtons = blockContainer.querySelectorAll('button.submit, .submit.action, .footer-data__submittext, button[type="submit"], .action.submit, button.action.submit.classic-button, button.action.submit, .action.submit.classic-button.footer-data__submittext, button[class*="submit"], button[class*="action"]');
      }
      
      // Log all buttons found for debugging
      if (submitButtons.length === 0) {
        const allButtons = blockContainer.querySelectorAll('button');
        allButtons.forEach(function(btn, idx) {
          const classes = btn.className || '';
          const text = btn.textContent || btn.innerText || '';
        });
      }
      
      submitButtons.forEach(function(btn, btnIndex) {
        // Remove any existing listeners by cloning
        const newBtn = btn.cloneNode(true);
        if (btn.parentNode) {
          btn.parentNode.replaceChild(newBtn, btn);
        }
        
        newBtn.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          handleFormSubmit(e);
        });
      });
    });
  }
  
  function initializeButtonHoverEffects() {
    // Initialize hover effects for buttons with data-hover-bg attribute
    const blockContainer = document.getElementById("easy-form-{{ block.id }}");
    if (!blockContainer) return;
    
    const buttons = blockContainer.querySelectorAll('.footer .action.submit.classic-button[data-hover-bg], .footer .action.reset.classic-button[data-hover-bg]');
    
    buttons.forEach(function(button) {
      const hoverBg = button.getAttribute('data-hover-bg');
      
      if (hoverBg) {
        // Get original colors from inline style attribute
        const styleAttr = button.getAttribute('style') || '';
        let originalBg = '';
        let originalBorder = '';
        
        // Extract background-color and border-color from style attribute
        const bgMatch = styleAttr.match(/background-color:\s*([^;]+)/i);
        const borderMatch = styleAttr.match(/border-color:\s*([^;]+)/i);
        
        if (bgMatch) {
          originalBg = bgMatch[1].trim();
        } else {
          // Fallback to computed style
          originalBg = window.getComputedStyle(button).backgroundColor;
        }
        
        if (borderMatch) {
          originalBorder = borderMatch[1].trim();
        } else {
          // Fallback to computed style
          originalBorder = window.getComputedStyle(button).borderColor;
        }
        
        // Store original colors
        button.setAttribute('data-original-bg', originalBg);
        button.setAttribute('data-original-border', originalBorder);
        
        // Mouse enter - apply hover color to both background and border
        button.addEventListener('mouseenter', function() {
          this.style.backgroundColor = hoverBg;
          this.style.borderColor = hoverBg;
        });
        
        // Mouse leave - restore original colors
        button.addEventListener('mouseleave', function() {
          const origBg = this.getAttribute('data-original-bg') || originalBg;
          const origBorder = this.getAttribute('data-original-border') || originalBorder;
          this.style.backgroundColor = origBg;
          this.style.borderColor = origBorder;
        });
      }
    });
    
  }
  
  function initializeFloatingForm() {
    // Initialize floating form popup functionality
    const blockContainer = document.getElementById("easy-form-{{ block.id }}");
    if (!blockContainer) return;
    
    // Check if this is a floating form (has the floating-form-icon element)
    const floatingIcon = blockContainer.querySelector('.floating-form-icon');
    if (!floatingIcon) {
      return;
    }
    
    const overlay = blockContainer.querySelector('.floating-form-overlay');
    const closeBtn = blockContainer.querySelector('.floating-form-close');
    
    if (!overlay || !closeBtn) {
      return;
    }
    
    
    // Open popup when icon is clicked
    floatingIcon.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
    });
    
    // Close popup when close button is clicked
    closeBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      overlay.classList.remove('active');
      document.body.style.overflow = ''; // Restore scrolling
    });
    
    // Close popup when clicking outside the form
    overlay.addEventListener('click', function(e) {
      if (e.target === overlay) {
        overlay.classList.remove('active');
        document.body.style.overflow = ''; // Restore scrolling
      }
    });
    
    // Close popup on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && overlay.classList.contains('active')) {
        overlay.classList.remove('active');
        document.body.style.overflow = ''; // Restore scrolling
      }
    });
    
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeFormBuilder);
  } else {
    // DOM already loaded
    initializeFormBuilder();
  }
  
  // Also try after a short delay (for Theme Customizer)
  setTimeout(initializeFormBuilder, 100);
  
  // Listen for Shopify theme editor events
  if (typeof window.Shopify !== 'undefined' && window.Shopify.designMode) {
    document.addEventListener('shopify:section:load', initializeFormBuilder);
    document.addEventListener('shopify:block:select', initializeFormBuilder);
  }
})();
</script>

{% schema %}
{
  "name": "Easy Form Builder",
  "target": "section",
  "settings": [
    {
      "type": "paragraph",
      "content": "Add a form created in the Easy Form Builder app to your page."
    },
    {
      "type": "header",
      "content": "Form Settings"
    },
    {
      "type": "text",
      "id": "form_id",
      "label": "Form ID",
      "info": "Enter the Form ID of the form you created in the Easy Form Builder app. You can find this ID in your app dashboard.",
      "default": "0"
    },
    {
      "type": "header",
      "content": "Display Settings"
    },
    {
      "type": "range",
      "id": "form_width",
      "label": "Form Width (%)",
      "min": 50,
      "max": 100,
      "step": 5,
      "default": 100,
      "unit": "%"
    },
    {
      "type": "select",
      "id": "form_alignment",
      "label": "Form Alignment",
      "options": [
        {
          "value": "left",
          "label": "Left"
        },
        {
          "value": "center",
          "label": "Center"
        },
        {
          "value": "right",
          "label": "Right"
        }
      ],
      "default": "center"
    }
  ]
}
{% endschema %}

